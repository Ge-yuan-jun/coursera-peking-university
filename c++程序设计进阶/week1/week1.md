### 一、引用
类型名 & 引用名 = 某变量名
```c++
int n = 4;
int &r = n; // r引用了n， r的类型是 int &
```

某个变量的引用，等价于这个变量，相当于该变量的一个别名。所以，引用值改变，则被引用的变量也改变（类似于js中的对象引用）

定义引用时，一定要将其×××初始化×××成引用某个变量

初始化后，它就一直引用该变量，不会再引用别的变量了。

引用只能引用变量，不能引用常量跟表达式

引用示例：交换两个整型变量值的函数
```
void swap(int *a, int *b) {
    int temp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}
int n1,n2;
swap(&n1, &n2);
```

上面的写法有效果，但是很丑陋。看引用的用法：
```
void swap(int & a, int & b) {
    int temp;
    tmp = a;
    a = b;
    b = tmp;
}
int n1,n2;
swap(&n1, &n2);
```
引用作为函数的返回值：
```
int n = 4;
int & SetValue() {return n;}
int main() {
    SetValue() = 40;
    cout << n; // 40
    return 0;
}
```
##### 常引用
定义引用时，前面加`const`关键字，即为“常引用”

```
int n;
const int & r = n;
```

### 二、常量
1. 定义常量
2. 定义常量指针
    - 不可以通过常量指针修改其指向的内容
    - 不能把常量指针赋值给非常量指针，反过来可以

    ```
    const int * p1;int * p2;
    p1 = p2;    // ok
    p2 = p1;    // error
    p2 = (int *)p1; // ok,强制类型转换
    ```
    - 函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容
    ```
    void MyPrintf ( const char * p ) {
        strcpy(p, "this"); // 编译出错
        printf("%s", p); // ok
    }
    ```


### 三、动态内存分配
1. 用`new`运算符实现动态内存分配

  -  第一种用法：分配一个变量
  ```
  P = new T;
  ```
  T是任意**类型名**，P是类型为 **T *** 的指针
  动态分配出一块大小为 `sizeof(T)` 字节的内存空间，并且将该内存空间的**起始地址**赋值给`P`，比如：

  ```
  int * pn;
  pn = new int;
  * pn = 5;
  ```

  - 第二种用法：分配一个数组
  ```
  P = new T[N];
  ```
  T: 任意**类型名**
  P：类型为 **T *** 的指针
  N：要分配的数组元素的个数，可以使整型**表达式**

  动态分配出一片大小为`N * sizeof(T)`字节的内存空间，并且将该内存空间的**起始地址**赋值给`P`

  ```
  int * pn;
  int i = 5;
  pn = new int[i * 20];
  pn[0] = 20;
  pn[100] = 30; // 编译没问题，运行时导致数组越界
  ```

  - `new`运算符的返回值类型

  ```
  new T;
  new T[n];
  ```

  这两个返回式的表达式类型都是 `T *`

  `int * p = new int;`

2. 用`delete`运算符释放动态分配的内存

  - 用`new`动态分配的内存空间，一定要`delete`运算符进行释放

  `delete`指针：该指针必须指向`new`出来的空间

  ```
  int * p = new int;
  * p = 5;
  delete p;
  delete p; // 导致异常，一片空间不能被delete多次
  ```

  - 用`delet`释放动态分配的数组，要加`[]`

  `delete []`指针：该指针必须指向`new`出来的数组

  ```
  int * p = new int[20];
  p[0] = 1;
  delete [] p;
  ```
