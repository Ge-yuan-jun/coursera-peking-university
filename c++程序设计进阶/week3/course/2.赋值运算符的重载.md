### 一、赋值运算符'='重载

赋值运算符两边的类型可以不匹配
  1. 把一个`int`类型变量赋值给一个`Complex`对象
  2. 把一个`char *`类型的字符串赋值给一个字符串对象

需要**重载赋值运算符 =**

赋值运算符“=”只能重载为**成员函数**

### 二、赋值运算符重载示例

编写一个长度可变的字符串类`String`
- 包含一个`char *`类型的成员变量 -> 指向动态分配的存储空间
- 该存储空间用于存放`\0`结尾的字符串

```
class String {
  private:
    char * str;
  public:
    String():str(NULL){} // 构造函数，初始化str为NULL
    const char * c_str() {return str;} // 保证不能通过指针来修改内存空间里面的内容
    char * operator = (const char * s); // 赋值运算符的重载函数
    ~String(); // 析构函数
}

// 重载 '=' -> obj = 'hello'能够成立
char * String::operator = (const char * s){
  if (str) delete [] str;
  if (s) { // s不为NULL才会执行拷贝
    str = new char[strlen(s)+1];
    strcpy(str, s);
  } else {
    str = MULL;
  }
  return str;
}

String::~String(){
  if (str) {delete [] str;}
};

int main() {
  String s;
  s = "Good Luck";
  cout << s.c_str() << endl;
  // String s2 = "hello!"; //这条语句要是不注释就会出错
  s = "ShenZhou 8!";
  cout << s.c_str() << endl;
  return 0;
}
```
